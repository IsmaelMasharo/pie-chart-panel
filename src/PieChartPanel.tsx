// @ts-nocheck
import React from 'react';
import { PanelProps } from '@grafana/data';
import { PieChartOptions } from 'types';
import * as d3 from 'd3';
import { Swatches } from './legend';

// PURE JSX IMPLEMENTATION
export const PieChartPanel = ({ options, data, width, height }) => {
  // -----------------------    CHART CONSTANTS    -----------------------
  const CHART_REQUIRED_FIELDS = { category: 'category', value: 'value' };
  const LEGEND_POSITION = { bottom: 'bottom', right: 'right' };

  // -----------------------  CHART CONFIGURATION  -----------------------
  const config = {
    background: '#f8f8fa',
    legendPosition: options.legendPosition,
    color: options.colorScale,
    verticalLegend: false,
    pieCentered: options.pieCentered,
    displayTotals: options.displayTotals,
  };

  const marginLegendVisible =
    config.legendPosition === LEGEND_POSITION.bottom || config.legendPosition === LEGEND_POSITION.right;

  // ----------------------- BASE DATA ACQUISITION -----------------------
  const frame = data.series[0];
  const dataLen = frame.length;
  const indices = d3.range(dataLen);

  // -----------------------       ACCESSORS      -----------------------
  const categoryAccesor = frame.fields.find(field => field.name === CHART_REQUIRED_FIELDS.category);
  const valueAccesor = frame.fields.find(field => field.name === CHART_REQUIRED_FIELDS.value);

  // -----------------------      VALIDATIONS     -----------------------
  if (!(categoryAccesor && valueAccesor)) {
    throw new Error(`Required fields not present: ${Object.keys(CHART_REQUIRED_FIELDS).join(', ')}`);
  }

  // -----------------------  CHART FIELD VALUES  -----------------------
  const values = valueAccesor.values.toArray();
  const categories = categoryAccesor.values.toArray();
  const total = d3.sum(values);

  // -----------------------    CHART DIMENSIONS  -----------------------
  const panelMinDimension = Math.min(width, height);
  const panelMaxDimension = Math.max(width, height);

  const dimensions = {
    width: panelMaxDimension,
    height: panelMaxDimension,
    marginTop: 20,
    marginRight: 20,
    marginBottom: 20,
    marginLeft: 20,
  };

  dimensions.boundedWidth = dimensions.width - dimensions.marginLeft - dimensions.marginRight;
  dimensions.boundedHeight = dimensions.height - dimensions.marginTop - dimensions.marginBottom;

  // PIE POSITIONS WILL BE PLACED USING THE SVG COORDINATE SYSTEM
  const pieOuterRadius = Math.min(dimensions.boundedWidth, dimensions.boundedHeight) / 2;
  const pieInnerRadius = config.displayTotals ? pieOuterRadius / 2.2 : 0;
  const pieCenter = [dimensions.boundedWidth / 2, dimensions.boundedHeight / 2];

  // ARC ANNOTATION VISIBILITY PARAMS
  const maxArcRotationAngleRadi = 0.3;
  const minVisibleArcAngleRadi = 0.1;

  // VARIABLES USED IF THE PIE SHOULD BY CENTERED AND THE LEGEND PLACED AT ITS RIGHT
  // SINCE IN THIS CASE THE LEGEND WILL BE POSITIONED ABSOLUTLY
  const chartScaleFactor = panelMinDimension / panelMaxDimension;
  const legendOffsetFromCenter = pieOuterRadius * chartScaleFactor;
  const legendPositionAtRight = width / 2 + legendOffsetFromCenter;
  const rightAbsoluteStyle = { position: 'absolute', left: legendPositionAtRight };
  const rightAbsolute = config.legendPosition === LEGEND_POSITION.right && config.pieCentered;

  // VARIABLE USED IF THE PIE IS NOT REQUIRED TO BE CENTERED BUT THE LEGEND SHOULD BE PLACED AT ITS RIGHT
  // IN THIS CASE THE POSITIONING WILL BE HANDLED BY A REGULAR FLEX CONTAINER CONFIGURATION
  const rightFlex = config.legendPosition === LEGEND_POSITION.right && !config.pieCentered;

  // PIE ANNOTATIONS (VALUE %)
  const baseLegendSize = 14;
  const scaledLegendSize = baseLegendSize / chartScaleFactor;
  const scaledTotalSize = scaledLegendSize * 2;
  const annotationRadiusFactor = config.displayTotals ? 0.72 : 0.6;
  const annotationRadius = pieOuterRadius * annotationRadiusFactor;

  // -----------------------    CHART ELEMENTS    -----------------------
  // COLOR
  const colorInterpolator = d3[`interpolate${config.color}`];

  // domain starts at -1 to avoid using the lighter tone generated by interpolator
  const colorByIndex = d3
    .scaleSequential()
    .domain([-1, dataLen])
    .interpolator(colorInterpolator);

  const colorByCategory = d3.scaleOrdinal(
    categories,
    indices.map(i => colorByIndex(i))
  );

  // ANGLE GENERATOR
  const pie = d3
    .pie()
    .sort(null)
    .padAngle(0.02);

  // ARC ANGLES
  const arcs = pie(values);

  // ARC GENERATOR
  const arc = d3
    .arc()
    .innerRadius(pieInnerRadius)
    .outerRadius(pieOuterRadius)
    .cornerRadius(6);

  // ARC ANNOTATION POSITIONING
  const arcAnnotation = d3
    .arc()
    .innerRadius(annotationRadius)
    .outerRadius(annotationRadius);

  const radToDegree = d => (d * 180) / Math.PI;

  const rotateAnnotation = d => d.endAngle - d.startAngle < maxArcRotationAngleRadi;
  const displayAnnotation = d => d.endAngle - d.startAngle > minVisibleArcAngleRadi;

  const rotateRadialAnnotation = d => {
    // only rotate text if arc is to thin
    if (!rotateAnnotation(d)) {
      return 0;
    }

    // this will always be a positive number since d3.pie startAngle and endAngle are between 0-360 degrees
    const radialPieAngle = radToDegree((d.startAngle + d.endAngle) / 2);

    // d3.pie coordinate system: 0 degree at 12 o'clock clockwise direction
    // svg coordinate system:    0 degree at 3 o'clock clockwise direction by default (prior any transformation)
    const pieToSvgCoordinatesFactor = 90;
    const radialSvGAngle = radialPieAngle + pieToSvgCoordinatesFactor;

    // Upsidedown letters will require an extra text rotation:
    // text between 0-90 will end up with the word pointing to the first cuadrant (in svg coordinates)
    // text between 270-360 will end up with the word pointing to the fourth cuadrant (in svg coordinates)
    // text between 90-180  will end up with the word pointing to the second cuadrant (in svg coordinates) --> upsidedown letter
    // text between 180-270 will end up with the word pointing to the third cuadrant (in svg coordinates) --> upsidedown letter
    const upsideownRotation = radialSvGAngle > 90 && radialSvGAngle < 270 ? radialSvGAngle + 180 : radialSvGAngle;

    return upsideownRotation;
  };

  // VALUE FORMATING
  const formatValue = value => d3.format('.2~f')(value);
  const formatPercent = percent => d3.format('.1~%')(percent);
  const formatThousand = value => d3.format('.3~s')(value);

  // ------------------------------- CHART  ------------------------------
  const chart = svg => {
    // BOUNDS
    const bounds = svg.append('g').attr('transform', `translate(${dimensions.marginLeft}, ${dimensions.marginTop})`);

    // PIE CONTAINER
    const pie = bounds.append('g').attr('transform', `translate(${pieCenter})`);

    // PIE
    pie
      .selectAll('path')
      .data(arcs)
      .join('path')
      .attr('stroke', 'white')
      .attr('fill', d => colorByIndex(d.index))
      .attr('d', arc)
      .append('title')
      .text(
        (d, i) =>
          `${categoryAccesor.values.get(i)}\nTotal: ${formatValue(d.value)}\nPercentage: ${formatPercent(
            d.value / total
          )}`
      );

    // PIE ANNOTATION
    pie
      .append('g')
      .attr('font-size', scaledLegendSize)
      .attr('text-anchor', 'middle')
      .attr('pointer-events', 'none')
      .selectAll('text')
      .data(arcs)
      .join('text')
      .attr('dy', '0.35em')
      .attr('transform', d => `translate(${arcAnnotation.centroid(d)}) rotate(${rotateRadialAnnotation(d)})`)
      .filter(displayAnnotation)
      .call(text =>
        text
          .append('tspan')
          .attr('font-weight', 'bold')
          .each((d, i, nodes) => {
            if (!rotateAnnotation(d)) {
              d3.select(nodes[i]).attr('y', '-0.4em');
            }
          })
          .text(d => formatPercent(d.value / total))
      )
      .call(
        text =>
          config.displayTotals &&
          text
            .append('tspan')
            .attr('fill-opacity', 0.7)
            // display totals next to percentage if annotation should rotate
            // display bellow otherwise
            .each((d, i, nodes) => {
              if (!rotateAnnotation(d)) {
                d3.select(nodes[i])
                  .attr('x', 0)
                  .attr('y', '1em');
              }
            })
            .text(d => {
              const value = formatThousand(d.value);
              return rotateAnnotation(d) ? ` - ${value}` : value;
            })
      );

    config.displayTotals &&
      pie
        .append('text')
        .attr('font-size', scaledTotalSize)
        .attr('text-anchor', 'middle')
        .attr('dy', '0.4em')
        .text(total);
  };

  return (
    <div
      style={{
        width,
        height,
        background: config.background,
        overflow: 'hidden',
        display: 'flex',
        flexDirection: rightFlex ? 'row' : 'column',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative',
      }}
    >
      <svg
        // Not using width nor height since the horizontal legend will overflow.
        // By letting scale the svg with viewbox it is posible to keep both chart
        // and bottom legend together
        // ------------------------------------------------------------------------
        // For a legend placed at the RIGHT OF THE CHART
        // AND if the chart is required to be centered in the container no matters what
        // AND if it is required to be kept close to the actual chart (aka. LEGEND_POSITION = f(CHART SIZE + LEGEND_PADDING))
        // in THAT SPECIFIC CASE it will be necesary to set the widht and height
        // of the svg to be the same as the viewBox since only in that way its
        // posible to guarantee the condition both for svg or div legend
        // ------------------------------------------------------------------------
        // ANOTHER less restrictive option KEEPING THE CHART CENTERED
        // is to place the legend in function of the chart margins: LEGEND_POSITION = f(CHART MARGINS)
        // ------------------------------------------------------------------------
        // ANOTHER less restrictive and easier option is just to place the chart and legend
        // in a flex container and letting the splitting be handle internally
        // IN THIS CASE I find that while keeping just the height of the svg to 100% was enough
        // to keep the legend close to the pie. This happens because the width of the svg is
        // handle internally (not set by programmer) and fits the svg content rather than its parent
        // ------------------------------------------------------------------------
        // SO I FIND THE SOLUTION, it wasn't about using width or height, but it was
        // necessary that BOTH HAVE THE SAME DIMENSION. When setting independent width and height
        // the svg was trying to occupy the whole space provided by its parent. By setting
        // width and height to be equal the svg then could fit to its container. THAT FIXED THE BOTTOM LEGEND TO GO WAY TO THE MARGIN
        // TO FIX THE LEGEND POSITIONED AT THE RIGHT SIDE in f(CHART SIZE + LEGEND_PADDING)) and KEEPING CHART CENTERED
        // it was required to calculate this:
        //    Math.min(width, height) / Math.max(width, height)
        // which represents the scale factor for the pie chart diameter
        // and this
        //    svgWidth: Math.max(width, height)
        // I don't fully understand it yet, but in the meantime it does the "trick"
        viewBox={`0 0 ${dimensions.width} ${dimensions.height}`}
        height={rightFlex ? '100%' : undefined}
        ref={node => {
          d3.select(node)
            .selectAll('*')
            .remove();
          d3.select(node).call(chart);
        }}
      />
      {marginLegendVisible ? (
        <Swatches
          color={colorByCategory}
          marginLeft={dimensions.marginLeft}
          verticalLegend={config.verticalLegend || config.legendPosition === LEGEND_POSITION.right}
          style={rightAbsolute ? rightAbsoluteStyle : {}}
        />
      ) : null}
    </div>
  );
};
